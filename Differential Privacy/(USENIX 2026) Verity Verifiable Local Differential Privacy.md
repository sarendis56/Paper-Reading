## (USENIX 2026) Verity: Verifiable Local Differential Privacy

This paper addresses a critical vulnerability in **Local Differential Privacy (LDP)** protocols: **poisoning attacks**. While LDP protects user privacy by adding noise to data before it leaves the user's device, this same noise mechanism allows malicious users to manipulate aggregate results significantly more than they could by simply lying about their inputs.

The authors propose two novel, non-interactive protocols to solve this:

1. **Verity-Auth:** Designed for scenarios where a trusted third party (authorizer) can verify the input (e.g., medical results).
2. **Verity:** Designed for scenarios where users self-generate inputs (e.g., surveys) and **no** ground truth exists.

#### The Core Problem: Poisoning & LDP

In standard LDP, users randomize their input $x$ to produce a noisy response $y$. The server aggregates these responses to estimate statistics.

- **The Vulnerability:** Malicious users can attack the system in two ways:
  - **Input Tampering:** Falsifying the input data (possible in any system).
  - **Randomizer Tampering:** Skipping the noise generation and submitting a fabricated response $y$ directly. This is specific to LDP and far more damaging, allowing adversaries to amplify error by a factor of $1/\epsilon$ (where $\epsilon$ is the privacy parameter).
- **Drop-Out Attacks:** A malicious user might generate noise honestly but "drop out" (refuse to send data) if the noise flips their bit in a way they dislike. This paper is the first to explicitly analyze drop-out attacks in verifiable LDP.

#### Solution I: Verity-Auth (With Authorized Input)

This protocol is for settings where a third party holds "ground truth" (e.g., a hospital knows a user's COVID status, or an advertiser knows a conversion occurred).

- **How it Works:**
  1. **Authorization:** The user proves to an Authorizer that their input matches the ground truth. The Authorizer issues a **blind signature**, ensuring the Authorizer cannot link the specific user to the final report sent to the server (preserving unlinkability).
  2. **Noise Sampling:** The user generates noise using a **Pseudorandom Function (PRF)**. The key for this PRF is derived jointly by the user and the server, preventing the user from "cherry-picking" favorable noise.
  3. **Verification:** The user submits the noisy response along with a **Zero-Knowledge Proof (ZKP)**. This proof confirms that the response was generated by correctly running the randomized response mechanism on the signed, authorized input.
- **Security Guarantee:** Prevents both input tampering and randomizer tampering. The only remaining error is the statistical noise inherent to LDP.
- **Efficiency:** Highly efficient. It takes the user roughly **8.37ms** to generate a proof and the server **3.54ms** to verify it.

#### Solution II: Verity (Without Authorized Input)

This protocol is for settings where users generate their own data (e.g., opinion polls), meaning input tampering cannot be prevented. The goal is to prevent **randomizer tampering**.

- **The Challenge:** If a malicious user can see the noise (randomness) in the clear, they can adjust their input to force a specific output. Therefore, the randomness must be hidden even from the user.
- **How it Works:**
  1. **Encrypted Randomness:** The protocol keeps the randomness encrypted. Users evaluate the PRF under **Homomorphic Encryption (HE)**.
  2. **Deterministic Verification:** Instead of using heavy ZKPs for the encryption steps (which is inefficient), Verity leverages the deterministic nature of HE ciphertexts. The server re-runs the homomorphic operations on the encrypted inputs and checks if the resulting ciphertexts match the user's submission.
- **Security Guarantee:** Limits the adversary to input tampering only. They cannot exploit the randomness to bias results.
- **Efficiency:** Due to Homomorphic Encryption, this is computationally heavier. It takes the user approximately **1424 seconds** (online time) to generate a verifiable bit, though batching is possible.

------

#### Key Technical Innovations

- **Non-Interactivity:** Both protocols preserve the "one-shot" nature of Randomized Response. Users prepare and submit contributions without needing multiple rounds of online interaction with the server, which is crucial for mobile devices with limited connectivity.
- **Legendre PRF:** The authors use the Legendre PRF for generating randomness because it is efficient and "ZKP-friendly" (easy to prove in arithmetic circuits).
  - Standard PRFs like SHA-256 or AES are "ZKP-hostile" because they rely on bit-shifts and XORs.
  - Verity uses the **Legendre PRF**, which relies on modular exponentiation. This is algebraic and extremely cheap to prove in ZK.
- **ZKP systems:**
  - This paper: **Bulletproofs** (Range Proofs / Arithmetic Circuits).
    - *Why:* It allows for transparent setup (no trusted setup ceremony required) and produces small proofs (logarithmic size).
    - Instead of allowing *any* probability like 0.73 or 0.75, they restrict the probability to powers of $1/2$ (e.g., $1/2, 1/4, 1/8$).
      - See why this is costly below.
    - **No Comparison Needed:** To get a probability of $1/8$, they simply take 3 random bits ($b_1, b_2, b_3$) and multiply them: $b_{final} = b_1 \times b_2 \times b_3$.
    - Since multiplication is just **one gate** in a ZK circuit, this is massively more efficient than the "Large Random + Comparison" method.
  - In Bontekoe et al., PoPETs 2025: **Groth16 (zk-SNARK)**.
    - *Why:* It has **constant proof size** (very small) and **constant verification time**, regardless of how complex the circuit is. This is crucial because their circuit is massive.
    - *Trade-off:* It requires a **Trusted Setup**. If the setup key leaks, proofs can be forged. (The authors argue the server can generate this, assuming a semi-honest server model).
    - For PRF evaluation: They use **Blake2s**, a standard cryptographic hash.
      - *Cost:* Blake2s uses bitwise XORs and rotations. In a ZK circuit (which works over prime fields), these operations must be "emulated" by breaking numbers into bits. This consumes tens of thousands of constraints (~20,000+ constraints per hash).
    - To support *any* LDP mechanism (not just RR), they generate a large random integer from the PRF and compare it to a threshold.
      - For example, to simulate that 0.75 probability using only uniform bits, Bontekoe et al. use the following method:
        - Generate a long string of $\ell$ random bits (e.g., 64 bits). When you interpret these bits as a single number, you get a large integer $R$ uniformly chosen between $0$ and $2^{64}-1$ (the maximum value).
        - Calculate a **threshold** $T$ based on the target probability. If the target is $75\%$ (0.75), the threshold is $75\%$ of the maximum value.
        - **If $R \le T$**: Output **1** (Heads).
        - **If $R > T$**: Output **0** (Tails).
      - To perform a "Less Than" ($<$) comparison in a ZK circuit, you cannot just compare two numbers directly. You must break the "Large Random" number down into its individual binary bits (e.g., all 64 bits) to prove that no "borrow" occurred during the subtraction $R - T$. This adds thousands of constraints to the circuit.
      - You must also strictly prove that the number $R$ is indeed a valid integer within the correct range $[0, 2^{\ell}-1]$, adding further overhead.
    - *Cost:* This requires range checks and greater-than/less-than comparators, which are expensive (requiring bit-decomposition gadgets).
- **Blind Signatures:** Verity-Auth uses a modified EQS-based blind signature to ensure that even if the Authorizer and Server collude, they cannot de-anonymize the user.

#### Performance Comparison

The authors benchmarked their work against concurrent solutions (e.g., Bontekoe et al., PoPETs 2025).

- **Verity-Auth** is approximately **100x more efficient** than the concurrent work, which requires 1.31 seconds per user compared to Verity-Auth's milliseconds execution.
- **Verity** (the encrypted version) is computationally expensive due to HE but is the first to provide robustness by keeping randomness encrypted in a non-interactive setting.

```
https://github-readme-stats.vercel.app/api?username=sarendis56&count_private=true&show_icons=true&theme=tokyonight
```

